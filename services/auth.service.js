const Users = require("../models/user.model");
const bcrypt = require("bcrypt");
const UserService = require("./user.service.js");
const UserServiceInstance = new UserService();
const jwt = require("jsonwebtoken");

class AuthService{
    
    encryptPassword = async(password) => {
         const salt = await bcrypt.genSalt();
         const hashedPassword = await bcrypt.hash(password, salt);
         console.log("hashed Password", hashedPassword);
         return hashedPassword;
    };

    signup = async(user) =>{
        try{
             
             const { fullName = "", email, username, password } = user; // if nothing is passed in fullName, assign it a null value as ""

             const encryptedPassword = await this.encryptPassword(password);
             const newUser = new Users({ email, username, fullName, password: encryptedPassword });
             const result = await newUser.save();
             return result;
        }

        catch(error){
             throw error;
        }
    }

     verifyCredentials = async(username, password)=>{
         // it will check if username exist
         const user = await UserServiceInstance.findByUsername(username);

         console.log(user);
        
         // once done with checking the username & if we assume that the username exist, so we have access to the user password in the DB, user.password(DB) and then  -> there is this password from client password(client).
         // Now we need to compare both of these, user.password(DB) & password()
         // so that is where where are again going to use the bcrypt package.
         if(user) // if user exist then result is either going to be either user or null.
         {
          const isValidPassword = await bcrypt.compare(password, user.password);

          if(isValidPassword){
               return user;
          }
          else{
               return null;
          }
         }  

         return null; // in case if the user does not exist at all
         
     }

generateToken = (username) =>{  // here we dont need async await as its a synchronous process
    try{
          const payload = {username}
          const options = {expiresIn: "1h"}
          const token = jwt.sign(payload, process.env.JWT_SECRET, options); // using the secret-key backend is going to know that this token is either generated by backend or its just some another random token.
          console.log("token", token);
          return token;
    }
    catch(error)
    {
       throw error;
    }
}

    login = async(user) =>{
     try{
          //  { isLoggedIn: true }
          // verification process yet to do
          // 1. Extract password from user then  -> verify if this is right or wrong then -> based on that create object with key isLoggedIn
          const {username, password} = user; // Extract password from user

          const userObj = await this.verifyCredentials(username, password);  // for user object "userObj" remember to put await here as waiting here is important 
          
          console.log("user result", user);

          if(userObj)
          {    
               console.log("userObject", userObj);
               const jwtToken = this.generateToken(username);
               //once the token has been generated, we try to return something that will set the token as cookie in the frontend

               return {isLoggedIn: true, token: jwtToken}; // encrypt this data in the form of token and then return that token to the frontend
          }

          else
          {
                return {isLoggedIn: false}
          }
     }

     catch(error){
          throw error;
     }
 }
}

module.exports = AuthService;